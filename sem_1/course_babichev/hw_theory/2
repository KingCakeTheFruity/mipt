1) 
Для поставленной задачи используем так называемую мега-кучу: структуру, которая в себе будет хранить кучу на минимумах для некоторого мн-ва эл-тов и кучу на максимумах для этих же элементов, поддерживая общую внешнюю индексацию между ними. Тогда на запрос вставки вставляем элемент за O(2 * logn) = O(logn), отвечаем на getMin() и getMax() за единицу (но можем увеличить это время до O(logn) при желании), удаляем элемент (не важно, макс. или мин.) из мега-кучи за O(logn), что и требуется.
[Спасибо задаче G из контеста]

2)
Пусть размер массива A - L1, B - L2
Вообразим себе таблицу L1 * L2, массив А представим над ним, В - слева, в виде столбца. Теперь клеточка [i, j] в воображамой таблице - это клетка, которая хранит в себе сумму A[i] + B[j] и свои координаты. Заведём кучу на минимумах, в качестве элементов будем использовать клетки воображаемой таблицы, в качестве ключа при сравнениях - сумму. Изначально пушнем [0, 0].
Кроме этого заведем сет для таких же элементов, чтобы знать, обрабатывали мы очередной элемент или нет, туда тоже положим [0, 0]
Теперь повторяем k раз: попаем минимальный элемент, пусть он [i, j]. Проверяем, нет ли в сете элементов [i+1, j] [i, j+1], кладем в сет и кучу, если нет. Так как для любого эл-та [x, y] верно, что все элементы, обе координаты которых меньше, имеют не большую сумму, получим, что мы обрабатываем элементы таким образом, что в каждый момент в нашей куче лежит не более чем (периметр уже обработанной фигуры) элементов. Т.к. мы не сможем уйти по координатам дальше (k+1, k+1) эл-та (плюс еденица на всякий случай), такой периметр будет не больше, чем 2*(k + 1), значит, в нашей куче в каждый момент времени будет не более O(k) элементов, а всего мы сделаем k попов, ища k-ю порядковую статистику.
Итоговая ассимптотика: О(klogk)

3)
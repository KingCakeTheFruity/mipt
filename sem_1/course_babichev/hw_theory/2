1) 
Для поставленной задачи используем так называемую мега-кучу: структуру, которая в себе будет хранить кучу на минимумах для некоторого мн-ва эл-тов и кучу на максимумах для этих же элементов, поддерживая общую внешнюю индексацию между ними. Тогда на запрос вставки вставляем элемент за O(2 * logn) = O(logn), отвечаем на getMin() и getMax() за единицу (но можем увеличить это время до O(logn) при желании), удаляем элемент (не важно, макс. или мин.) из мега-кучи за O(logn), что и требуется.
[Спасибо задаче G из контеста]

2)
Пусть размер массива A - L1, B - L2
Вообразим себе таблицу L1 * L2, массив А представим над ним, В - слева, в виде столбца. Теперь клеточка [i, j] в воображамой таблице - это клетка, которая хранит в себе сумму A[i] + B[j] и свои координаты. Заведём кучу на минимумах, в качестве элементов будем использовать клетки воображаемой таблицы, в качестве ключа при сравнениях - сумму. Изначально пушнем [0, 0].
Кроме этого заведем сет для таких же элементов, чтобы знать, обрабатывали мы очередной элемент или нет, туда тоже положим [0, 0]
Теперь повторяем k раз: попаем минимальный элемент, пусть он [i, j]. Проверяем, нет ли в сете элементов [i+1, j] [i, j+1], кладем в сет и кучу, если нет. Так как для любого эл-та [x, y] верно, что все элементы, обе координаты которых меньше, имеют не большую сумму, получим, что мы обрабатываем элементы таким образом, что в каждый момент в нашей куче лежит не более чем (периметр уже обработанной фигуры) элементов. Т.к. мы не сможем уйти по координатам дальше (k+1, k+1) эл-та (плюс еденица на всякий случай), такой периметр будет не больше, чем 2*(k + 1), значит, в нашей куче в каждый момент времени будет не более O(k) элементов, а всего мы сделаем k попов, ища k-ю порядковую статистику.
Итоговая ассимптотика: О(klogk)

3)
Зафиксируем некоторое k. Разобьем все элементы массива на подмассивы длины 2k+1, после чего запустимся рекурсивно от массива медиан. Мысленно теперь отсортируем и выстроим впорядке увеличения медиан эти подмассивы. Заметим, что для ответа существует n * (k + 1) / (2 * (2k + 1)) элементов, меньших и равных ему и больше и равных ему (видно из таблицы), т.е. в худшем случае n * (1 - это кол-во эл-тов) окажутся не на своих местах. Т.к. запускаясь рекрсивно мы каждый раз уменьшаем массив в 2k+1 раз, итого будем иметь следующее утв-е про его время работы:
T(n) <= T(n * 1/(2k+1)) + T(n * (3k - 1) / (4k + 2)) + C*n
Где С - константа, требуемая для сортировки подмассивов длины 2k+1
Легко доказать, что можно найти А такое, что A*n > T(n), т.е. T(n) = O(n)

При увеличении k можно видеть, что А все ещё остается возможным найти, причем это даже улучшало бы результат, если бы не C*n, т.к. в этом месте константа как раз таки будет расти. k = 1 не позволяет найти линейное A, чтобы T(n) оставалось O(n).
Таким образом получается, что k=2 - минимальное для становления линейным алгоритмом, а k>2, хоть и остается линейным, не является оптимальным из-за нахождения медиан подмассивов длины 2k+1.

4) 
Используем для этого... вектор. Все операции по push и pop уже работают за О(1) амортизированно, а операция "убрать меньшую половину" - это поиск медианы и переложение элементов в новый вектор за линию, который можно амортизировать до O(1) следующим образом:
При каждом пуше кладем монетку на элемент. Тогда при отсечении меньшей половины, которое выполняется за O(n), возьмем монетки со всех элементов массива, что даст нам сумму по 'положить' и 'взять' 0, после чего по ходу переложения элементов в новый вектор будем опять класть на них монетки. Итого всегда на элемете будет лежать 1 монетка, а ассимптотика всех операций - О(1) амортизированно